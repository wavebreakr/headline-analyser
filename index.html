<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8" />
<meta name="viewport" content="width=device-width, initial-scale=1" />
<title>Ultimate Language Simplifier</title>

<style>
  body {
    font-family: system-ui, -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, sans-serif;
    margin: 0; padding: 0; color: #333;
    background: linear-gradient(135deg, #e0f7fa 0%, #b3e5fc 100%);
    min-height: 100vh; display: flex; align-items: center; justify-content: center;
  }

  .container {
    max-width: 650px; width: 90%; margin: 32px auto; padding: 30px; border-radius: 20px;
    background: rgba(255, 255, 255, 0.25);
    box-shadow: 0 8px 32px 0 rgba(0, 0, 0, 0.1);
    backdrop-filter: blur(10px); -webkit-backdrop-filter: blur(10px);
    border: 1px solid rgba(255, 255, 255, 0.4);
  }

  h2 { margin-top: 0; color: #1a237e; text-align: center; font-weight: 700; letter-spacing: -0.5px; }

  /* INTRO TEXT STYLES */
  .intro-text {
    background: rgba(255, 255, 255, 0.4);
    padding: 15px;
    border-radius: 10px;
    margin-bottom: 20px;
    border-left: 5px solid #42a5f5; /* Light blue accent bar */
  }

  .intro-text p {
    margin: 0;
    font-size: 15px;
    line-height: 1.5;
    color: #1a237e;
    font-weight: 500;
  }
  /* END INTRO TEXT STYLES */

  textarea {
    width: 100%; min-height: 180px; padding: 15px; font-size: 16px; line-height: 1.6;
    border-radius: 12px; box-sizing: border-box; font-family: inherit; resize: vertical;
    background: rgba(255, 255, 255, 0.7); border: 1px solid rgba(255, 255, 255, 0.5);
    transition: all 0.3s ease; margin-bottom: 8px;
  }
  
  textarea:focus { background: white; outline: none; border-color: #42a5f5; }

  .action-area { margin: 15px 0 15px; }

  button {
    width: 100%; padding: 18px; font-size: 18px; font-weight: 700; border: none; border-radius: 12px;
    background: #1a237e; color: white; cursor: pointer;
    box-shadow: 0 4px 15px rgba(26, 35, 126, 0.3); transition: all 0.2s;
  }

  button:hover { background: #283593; transform: translateY(-1px); box-shadow: 0 6px 20px rgba(26, 35, 126, 0.4); }

  #outputText { background: rgba(255, 255, 255, 0.5); font-weight: 500; }
  
  /* STATS AND COPY BUTTON STYLES */
  
  .stat-row {
    display: flex;
    justify-content: space-between;
    align-items: center;
    margin-bottom: 12px;
  }
  
  .word-count {
    font-size: 14px;
    color: #3949ab;
    padding: 4px 8px;
    border-radius: 4px;
    background: rgba(255, 255, 255, 0.5);
    font-weight: 500;
  }

  #copyButton {
    padding: 10px;
    font-size: 16px;
    font-weight: 600;
    margin-top: -5px;
    margin-bottom: 15px;
    background: #42a5f5;
    box-shadow: 0 2px 5px rgba(66, 165, 245, 0.4);
  }
  
  #copyButton:hover { 
    background: #1e88e5; 
    box-shadow: 0 3px 6px rgba(30, 136, 229, 0.5);
  }
</style>
</head>

<body>
<div class="container">
  <h2>Simplifier</h2>

  <div class="intro-text">
      <p>
          <strong>Instantly achieve clarity and precision.</strong> It takes complex textâ€”the jargon, long phrases, and heavy wordsâ€”and converts it into simple, direct, and easy-to-read language.
      </p>
  </div>
  <textarea id="inputText" placeholder="Paste complex text here..."></textarea>
  <div class="stat-row">
    <div class="word-count" id="originalWordCount">Original Words: 0</div>
  </div>

  <div class="action-area">
    <button onclick="runSimplify()">Simplify Now</button>
  </div>

  <textarea id="outputText" readonly placeholder="Resulting simple text..."></textarea>
  
  <button id="copyButton" onclick="copyToClipboard()">Copy Simplified Text</button>
  
  <div class="stat-row">
    <div class="word-count" id="simplifiedWordCount">Simplified Words: 0</div>
  </div>
</div>

<script>
// --- DICTIONARIES (EXPANDED) ---

const phraseMap = {
    // New legal/business terms
    "is hereby deemed a material breach of this agreement": "is a major break of this contract",
    "notwithstanding the provisions": "even with the rules",
    "is currently contingent upon": "depends on",
    "The Lessee shall": "The renter must",
    "The Lessor shall": "The owner must",
    
    // Existing/Enhanced
    "is authorized to": "can",
    "is permitted to": "can",
    "in the event of": "if",
    "not later than": "by",
    "commencement of": "starting",
    "utilisation": "use",
    "endeavor": "try",
    "in order to": "to",
    "prior to": "before",
    "subsequent to": "after",
    "at this point in time": "now",
    "at that point in time": "then",
    "due to the fact that": "because",
    "owing to the fact that": "because",
    "as a result of": "because",
    "with regard to": "about",
    "in relation to": "about",
    "in respect of": "about",
    "is capable of": "can",
    "has the ability to": "can",
    "has the capacity to": "can",
    "there is a need to": "we must",
    "it is important to note that ": "",
    "it should be noted that ": "",
    "the purpose of this is to ": "",
    "it has been determined that ": "",
    "make use of": "use",
    "conduct an evaluation": "check",
    "take into consideration": "consider",
    "provides guidance for": "guides",
    "give an indication of": "show",
    "in the event that": "if",
    "notwithstanding the fact that": "although",
    "in the absence of": "without",
    "not in a position to": "cannot",
    "on the basis of": "by",
    "at a later date": "later",
    "perform a review of": "review",
    "is in receipt of": "gets",
    "in close proximity to": "near",
    "a number of": "many",
    "do an assessment of": "assess",
    "it is essential that": "we must",
    "shall consult with": "must ask",
    "will consult with": "will ask"
};

const wordMap = {
    // New and enhanced words
    "necessitate": "require", 
    "implementation": "use",
    "validation": "testing",
    "stipulated": "written",
    "accrued": "earned",
    "transmit": "send",
    "said": "the", // context-specific simplification
    "rigorous": "strict", // keeps the qualifier but simplifies the word
    
    // Existing
    "exhibit": "show",
    "exhibiting": "showing",
    "acquire": "get",
    "acquired": "got",
    "demonstrate": "show",
    "demonstrates": "shows",
    "expedite": "speed up",
    "expeditiously": "fast",
    "possesses": "has",
    "remuneration": "pay",
    "dialogue": "talk",
    "monetary": "money",
    "commence": "start",
    "commencing": "starting",
    "utilise": "use",
    "utilising": "using",
    "utilized": "used",
    "leverage": "use",
    "implement": "use",
    "facilitate": "help",
    "comprehensive": "full",
    "numerous": "many",
    "significant": "big",
    "insufficient": "not enough",
    "optimal": "best",
    "approximately": "about",
    "assistance": "help",
    "prioritise": "focus on",
    "initially": "first",
    "ultimately": "lastly",
    "methodology": "method",
    "objective": "goal",
    "discontinue": "stop",
    "subsequently": "later",
    "consequently": "so",
    "regarding": "about",
    "ascertain": "check",
    "ameliorate": "fix",
    "delineate": "show",
    "individuals": "people",
    "organisations": "groups",
    "evaluation": "check",
    "verification": "check",
    "establishment": "start",
    "requirements": "rules",
    "commitment": "pledge",
    "determination": "decision",
    "necessity": "need",
    "modification": "change",
    "clarification": "explain",
    "contingency": "chance",
    "submit": "send",
    "advise": "tell",
    "furnish": "give",
    "retain": "keep",
    "procure": "buy",
    "consult": "ask"
};

// Conjunctions are now replaced with a new sentence (Period + Capitalized replacement)
const conjunctionMap = {
    "furthermore": "Also",
    "moreover": "Also",
    "nevertheless": "But",
    "however": "But",
    "therefore": "So",
    "hence": "So",
    "accordingly": "So"
};

// --- CORE FUNCTIONS ---

function runSimplify() {
    const inputText = document.getElementById('inputText').value;
    document.getElementById('outputText').value = "";
    
    if (!inputText.trim().length) {
        updateStats("", "");
        return;
    }

    const simplifiedLines = inputText.split('\n').map(originalLine => {
        if (originalLine.trim().length === 0) {
            return originalLine;
        }

        let outputLine = originalLine;
        
        // Step 1: Apply all replacements (Phrases, Words, and Conjunctions)
        outputLine = simplifyLine(outputLine);
        
        // Step 2: Fix redundancy (must run after replacements to catch new simple words)
        outputLine = fixRedundancy(outputLine);

        // Step 3: Clean up capitalization and spacing
        outputLine = cleanAndCapitalize(outputLine, originalLine);
        
        return outputLine;
    });

    const outputText = simplifiedLines.join('\n');
    document.getElementById('outputText').value = outputText;
    updateStats(inputText, outputText);
}

function simplifyLine(line) {
    let result = line;
    
    // 1. Apply Phrase and Word Map replacements
    result = applyReplacements(result, phraseMap);
    result = applyReplacements(result, wordMap);

    // 2. Fix conjunction usage (e.g., ", furthermore " -> ". Also ")
    for (const complex in conjunctionMap) {
        const simple = conjunctionMap[complex];
        // This regex now finds ", complex" followed by optional space, and replaces it with ". Simple. "
        const regex = new RegExp("[,;]\\s*" + complex + "\\s*([\\.|,|\\s])", "gi");
        // Ensure the replacement starts a new sentence and the word is capitalized
        result = result.replace(regex, ". " + simple + ". ");
    }
    
    // 3. Simple punctuation fixes
    result = result.replace(/; \s*([A-Z])/gi, ". $1"); 
    result = result.replace(/, and /gi, " and ");
    result = result.replace(/, but /gi, " but ");
    result = result.replace(/, But /gi, ". But "); 

    return result;
}

function fixRedundancy(line) {
    // Expanded list of weak/filler intensifiers
    const weakAdverbs = ["most", "very", "highly", "result", "thorough", "robust", "full"];
    const absoluteAdjectives = ["best", "full", "perfect", "complete", "unique", "big", "strict", "major"];
    let result = line;

    weakAdverbs.forEach(adverb => {
        absoluteAdjectives.forEach(adjective => {
            // Regex to find: (weakAdverb) (optional whitespace) (absoluteAdjective)
            const regex = new RegExp("\\b" + adverb + "\\s+" + adjective + "\\b", "gi");
            result = result.replace(regex, (match) => {
                const lowerMatch = match.toLowerCase();
                // If the match contains both words, return only the adjective (with proper capitalization)
                if (lowerMatch.includes(adverb) && lowerMatch.includes(adjective)) {
                    // Return the adjective, attempting to preserve initial capitalization
                    return match.includes(adjective.toUpperCase()) ? adjective.toUpperCase() : adjective;
                }
                return adjective;
            });
        });
    });

    return result;
}

// --- UTILITY FUNCTIONS (Unchanged from previous revision) ---

function copyToClipboard() {
    const outputTextarea = document.getElementById('outputText');
    if (outputTextarea.value.trim().length === 0) {
        alert("Nothing to copy!");
        return;
    }
    outputTextarea.select();
    outputTextarea.setSelectionRange(0, 99999);
    document.execCommand('copy');
    
    const copyButton = document.getElementById('copyButton');
    const originalText = copyButton.innerText;
    copyButton.innerText = "Copied! ðŸŽ‰";
    
    setTimeout(() => {
        copyButton.innerText = originalText;
    }, 1500);
}

function updateStats(originalText, simplifiedText) {
    const originalCount = wordCount(originalText);
    const simplifiedCount = wordCount(simplifiedText);
    
    document.getElementById('originalWordCount').innerText = "Original Words: " + originalCount;
    document.getElementById('simplifiedWordCount').innerText = "Simplified Words: " + simplifiedCount;
}

function wordCount(text) {
    return text.trim().split(/\s+/).filter(Boolean).length;
}

function applyReplacements(text, map) {
    let result = text;
    const sortedKeys = Object.keys(map).sort((a, b) => b.length - a.length);

    sortedKeys.forEach(complex => {
        const isSingleWord = complex.split(' ').length === 1;
        const boundary = isSingleWord ? "\\b" : "";
        
        const regex = new RegExp(boundary + complex + boundary, "gi");

        result = result.replace(regex, (match) => {
            const simple = map[complex];
            if (!simple) {
                return "";
            }

            if (match === match.toUpperCase()) {
                return simple.toUpperCase();
            }
            if (match[0] === match[0].toUpperCase()) {
                return simple.charAt(0).toUpperCase() + simple.slice(1).toLowerCase();
            }
            return simple.toLowerCase();
        });
    });
    return result;
}

function cleanAndCapitalize(line, originalLine) {
    if (!line || line.trim().length === 0) {
        return line;
    }
    
    const listMarkerMatch = originalLine.match(/\s*([I|V|X|A-Za-z0-9]+\.|\*|-|â€¢)\s*/);
    const listMarker = listMarkerMatch ? listMarkerMatch[0] : "";
    
    let cleaned = line.substring(listMarker.length).trim();
    
    if (!listMarkerMatch) {
        cleaned = line;
    }

    cleaned = cleaned.replace(/([.?!]\s*)[a-z]/gi, (match, p1) => p1 + match.charAt(match.length - 1).toUpperCase());

    if (cleaned.length > 0) {
        cleaned = cleaned.charAt(0).toUpperCase() + cleaned.slice(1);
    }
    
    cleaned = cleaned.replace(/(\s+)/g, ' ')
                      .replace(/\s+\./g, '')
                      .replace(/\.\./g, '')
                      .replace(/\s+,/g, '')
                      .trim();

    return listMarker ? listMarker + cleaned : cleaned;
}

</script>
</body>
</html>
